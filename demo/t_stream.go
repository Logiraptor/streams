// Generated by: streamgen
// TypeWriter: stream
// Directive: +stream on main.T

// Stream implementation inspired by http://blog.golang.org/pipelines

package main

import (
	"sync"
)

type TStream struct {
	stream chan T
	done   chan struct{}
}

func newTStream(done chan struct{}) TStream {
	if done == nil {
		done = make(chan struct{})
	}
	return TStream{
		stream: make(chan T),
		done:   done,
	}
}

func TStreamFromSlice(a ...T) TStream {
	s := newTStream(nil)
	go func() {
		for _, x := range a {
			select {
			case s.stream <- x:
			case <-s.done:
				close(s.stream)
				return
			}
		}
		close(s.stream)
	}()
	return s
}

func TStreamFromGenerator(gen func() (T, bool)) TStream {
	s := newTStream(nil)
	go func() {
		for {
			if x, ok := gen(); ok {
				select {
				case s.stream <- x:
				case <-s.done:
					close(s.stream)
					return
				}
			} else {
				break
			}
		}
		close(s.stream)
	}()
	return s
}

func TStreamMerge(streams ...TStream) TStream {
	s := newTStream(nil)
	var wg sync.WaitGroup
	for _, stream := range streams {
		wg.Add(1)
		go func(stream TStream) {
			defer wg.Done()
			for x := range stream.stream {
				select {
				case s.stream <- x:
				case <-stream.done:
					return
				}
			}
		}(stream)
	}
	go func() {
		wg.Wait()
		close(s.stream)
	}()
	return s
}

func (t TStream) Filter(filter func(T) bool) TStream {
	s := newTStream(t.done)
	go func() {
		for x := range t.stream {
			if filter(x) {
				select {
				case s.stream <- x:
				case <-s.done:
					close(s.stream)
					return
				}
			}
		}
		close(s.stream)
	}()
	return s
}

func (t TStream) Modify(proc func(T) T) TStream {
	s := newTStream(t.done)
	go func() {
		for x := range t.stream {
			select {
			case s.stream <- proc(x):
			case <-s.done:
				close(s.stream)
				return
			}
		}
		close(s.stream)
	}()
	return s
}

func (t TStream) Each(proc func(T)) TStream {
	s := newTStream(t.done)
	go func() {
		for x := range t.stream {
			proc(x)
			select {
			case s.stream <- x:
			case <-s.done:
				close(s.stream)
				return
			}
		}
		close(s.stream)
	}()
	return s
}

func (t TStream) Drain() []T {
	var a []T
	for x := range t.stream {
		a = append(a, x)
	}
	return a
}

func (t TStream) Iter() chan T {
	return t.stream
}

func (t TStream) Next() T {
	return <-t.stream
}

func (t TStream) Close() {
	close(t.done)
}
